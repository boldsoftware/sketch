package claudetool

import (
	"strings"
	"testing"
)

func TestBashTool_enhancePentestingCommand(t *testing.T) {
	tool := &BashTool{}

	tests := []struct {
		name     string
		input    string
		expected []string // Expected flags/modifications to be present
	}{
		{
			name:     "nmap basic scan",
			input:    "nmap -sS 192.168.1.1",
			expected: []string{"-n", "-v", "--host-timeout", "300s", "DEBIAN_FRONTEND=noninteractive"},
		},
		{
			name:     "nmap with sudo",
			input:    "sudo nmap -sS 192.168.1.1",
			expected: []string{"-n", "-v", "--host-timeout", "300s"},
		},
		{
			name:     "nmap with path",
			input:    "/usr/bin/nmap -sS 192.168.1.1",
			expected: []string{"-n", "-v", "--host-timeout", "300s"},
		},
		{
			name:     "nmap already has flags",
			input:    "nmap -sS -n -v 192.168.1.1",
			expected: []string{"--host-timeout", "300s"},
		},
		{
			name:     "nikto scan",
			input:    "nikto -h http://example.com",
			expected: []string{"-nointeractive", "DEBIAN_FRONTEND=noninteractive"},
		},
		{
			name:     "sqlmap injection test",
			input:    "sqlmap -u http://example.com/page.php?id=1",
			expected: []string{"--batch", "--no-cast"},
		},
		{
			name:     "hydra brute force",
			input:    "hydra -l admin -P passwords.txt ssh://192.168.1.1",
			expected: []string{"-f"},
		},
		{
			name:     "dirb directory enumeration",
			input:    "dirb http://example.com",
			expected: []string{"-S"},
		},
		{
			name:     "gobuster directory scan",
			input:    "gobuster dir -u http://example.com -w /usr/share/wordlists/dirb/common.txt",
			expected: []string{"-q"},
		},
		{
			name:     "wpscan wordpress scan",
			input:    "wpscan --url http://example.com",
			expected: []string{"--no-banner", "--no-update"},
		},
		{
			name:     "masscan port scan",
			input:    "masscan -p80,443 192.168.1.0/24",
			expected: []string{"--rate", "1000", "--host-timeout", "300s"},
		},
		{
			name:     "non-pentesting command",
			input:    "ls -la /tmp",
			expected: []string{"DEBIAN_FRONTEND=noninteractive"}, // Only env vars
		},
		{
			name:     "complex nmap command",
			input:    "nmap -sS -A --script vuln -p 80,443 192.168.1.0/24",
			expected: []string{"-n", "-v", "--host-timeout", "300s"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tool.enhancePentestingCommand(tt.input)
			
			for _, expectedFlag := range tt.expected {
				if !strings.Contains(result, expectedFlag) {
					t.Errorf("Expected flag/modification '%s' not found in result: %s", expectedFlag, result)
				}
			}
			
			// Ensure original command components are still present
			originalParts := strings.Fields(tt.input)
			for _, part := range originalParts {
				if !strings.Contains(result, part) {
					t.Errorf("Original command part '%s' missing from result: %s", part, result)
				}
			}
		})
	}
}

func TestBashTool_insertFlag(t *testing.T) {
	tool := &BashTool{}

	tests := []struct {
		name     string
		command  string
		flag     string
		afterCmd string
		expected string
	}{
		{
			name:     "insert flag after nmap",
			command:  "nmap -sS 192.168.1.1",
			flag:     "-n",
			afterCmd: "nmap",
			expected: "nmap -sS -n 192.168.1.1",
		},
		{
			name:     "insert flag with sudo",
			command:  "sudo nmap -sS 192.168.1.1",
			flag:     "-v",
			afterCmd: "nmap",
			expected: "sudo nmap -sS -v 192.168.1.1",
		},
		{
			name:     "insert at end if no target",
			command:  "nmap -sS",
			flag:     "-n",
			afterCmd: "nmap",
			expected: "nmap -sS -n",
		},
		{
			name:     "insert before multiple targets",
			command:  "nmap -sS 192.168.1.1 192.168.1.2",
			flag:     "-v",
			afterCmd: "nmap",
			expected: "nmap -sS -v 192.168.1.1 192.168.1.2",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tool.insertFlag(tt.command, tt.flag, tt.afterCmd)
			if result != tt.expected {
				t.Errorf("Expected '%s', got '%s'", tt.expected, result)
			}
		})
	}
}

func TestBashTool_looksLikeTarget(t *testing.T) {
	tool := &BashTool{}

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		// IP addresses
		{name: "IPv4 address", input: "192.168.1.1", expected: true},
		{name: "IPv6 address", input: "2001:db8::1", expected: true},
		{name: "CIDR notation", input: "192.168.1.0/24", expected: true},
		{name: "IPv6 CIDR", input: "2001:db8::/32", expected: true},
		
		// Domain names
		{name: "domain name", input: "example.com", expected: true},
		{name: "subdomain", input: "www.example.com", expected: true},
		{name: "complex domain", input: "api.v2.example.com", expected: true},
		
		// Not targets
		{name: "flag", input: "-sS", expected: false},
		{name: "long flag", input: "--script", expected: false},
		{name: "file path", input: "/usr/share/wordlists/common.txt", expected: false},
		{name: "port number", input: "80", expected: false},
		{name: "port range", input: "80-443", expected: false},
		{name: "script name", input: "vuln", expected: false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tool.looksLikeTarget(tt.input)
			if result != tt.expected {
				t.Errorf("looksLikeTarget('%s') = %v, expected %v", tt.input, result, tt.expected)
			}
		})
	}
}

func TestBashTool_pentestingToolDetection(t *testing.T) {
	tool := &BashTool{}

	// Test that all known pentesting tools are detected and enhanced
	pentestingCommands := []string{
		"nmap -sS 192.168.1.1",
		"nikto -h http://example.com",
		"sqlmap -u http://example.com/page.php?id=1",
		"hydra -l admin -P passwords.txt ssh://192.168.1.1",
		"dirb http://example.com",
		"gobuster dir -u http://example.com -w wordlist.txt",
		"wpscan --url http://example.com",
		"enum4linux 192.168.1.1",
		"smbclient //192.168.1.1/share",
		"rpcclient -U '' 192.168.1.1",
		"crackmapexec smb 192.168.1.1",
		"masscan -p80,443 192.168.1.0/24",
	}

	for _, cmd := range pentestingCommands {
		t.Run("detect_"+strings.Fields(cmd)[0], func(t *testing.T) {
			original := cmd
			enhanced := tool.enhancePentestingCommand(cmd)
			
			// Enhanced command should be different (longer) than original
			if len(enhanced) <= len(original) {
				t.Errorf("Command was not enhanced: original='%s', enhanced='%s'", original, enhanced)
			}
			
			// Should contain environment variables
			if !strings.Contains(enhanced, "DEBIAN_FRONTEND=noninteractive") {
				t.Errorf("Enhanced command missing environment variables: %s", enhanced)
			}
		})
	}
}

func TestBashTool_nonPentestingCommandsUnchanged(t *testing.T) {
	tool := &BashTool{}

	// Test that non-pentesting commands only get environment variables
	normalCommands := []string{
		"ls -la /tmp",
		"cat /etc/passwd",
		"ps aux",
		"netstat -tulpn",
		"grep -r 'password' /var/log",
		"find / -name '*.conf'",
		"curl http://example.com",
		"wget http://example.com/file.txt",
	}

	for _, cmd := range normalCommands {
		t.Run("normal_"+strings.Fields(cmd)[0], func(t *testing.T) {
			enhanced := tool.enhancePentestingCommand(cmd)
			
			// Should have environment variables added (order may vary)
			expectedEnvVars := []string{
				"DEBIAN_FRONTEND=noninteractive",
				"NEEDRESTART_MODE=a",
				"UCF_FORCE_CONFFNEW=1",
			}
			for _, envVar := range expectedEnvVars {
				if !strings.Contains(enhanced, envVar) {
					t.Errorf("Normal command missing env var '%s': %s", envVar, enhanced)
				}
			}
			
			// Original command should be at the end
			if !strings.HasSuffix(enhanced, cmd) {
				t.Errorf("Original command should be preserved: %s", enhanced)
			}
		})
	}
}