// Package claudetool provides pentesting-specific tools for the Kifaru agent
package claudetool

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"time"

	"sketch.dev/llm"
)

// PentestTool provides pentesting workflow management
type PentestTool struct{}

// PentestTarget represents a target system for penetration testing
type PentestTarget struct {
	ID          string            `json:"id"`
	Name        string            `json:"name"`
	IPAddress   string            `json:"ip_address"`
	Domain      string            `json:"domain,omitempty"`
	Description string            `json:"description,omitempty"`
	Scope       []string          `json:"scope"`
	OutOfScope  []string          `json:"out_of_scope,omitempty"`
	Metadata    map[string]string `json:"metadata,omitempty"`
	CreatedAt   time.Time         `json:"created_at"`
	UpdatedAt   time.Time         `json:"updated_at"`
}

// PentestSession represents an active penetration testing session
type PentestSession struct {
	ID        string        `json:"id"`
	Target    PentestTarget `json:"target"`
	Phase     string        `json:"phase"`
	Status    string        `json:"status"`
	StartTime time.Time     `json:"start_time"`
	EndTime   *time.Time    `json:"end_time,omitempty"`
	Findings  []Finding     `json:"findings"`
	Notes     []string      `json:"notes"`
	Commands  []CommandLog  `json:"commands"`
}

// Finding represents a security finding
type Finding struct {
	ID          string            `json:"id"`
	Title       string            `json:"title"`
	Severity    string            `json:"severity"`
	Description string            `json:"description"`
	Evidence    []string          `json:"evidence"`
	CVSS        float64           `json:"cvss,omitempty"`
	CVE         string            `json:"cve,omitempty"`
	References  []string          `json:"references,omitempty"`
	Remediation string            `json:"remediation,omitempty"`
	Metadata    map[string]string `json:"metadata,omitempty"`
	CreatedAt   time.Time         `json:"created_at"`
}

// CommandLog represents executed commands during testing
type CommandLog struct {
	Command   string    `json:"command"`
	Output    string    `json:"output"`
	ExitCode  int       `json:"exit_code"`
	Timestamp time.Time `json:"timestamp"`
	Phase     string    `json:"phase"`
}

// PentestInput represents input for pentest operations
type PentestInput struct {
	Action string          `json:"action"`
	Data   json.RawMessage `json:"data,omitempty"`
}

// Run executes the pentesting tool
func (pt *PentestTool) Run(ctx context.Context, input json.RawMessage) ([]llm.Content, error) {
	var req PentestInput
	if err := json.Unmarshal(input, &req); err != nil {
		return nil, fmt.Errorf("failed to unmarshal pentest input: %w", err)
	}

	slog.InfoContext(ctx, "pentest tool action", "action", req.Action)

	switch req.Action {
	case "create_target":
		return pt.createTarget(ctx, req.Data)
	case "start_session":
		return pt.startSession(ctx, req.Data)
	case "update_phase":
		return pt.updatePhase(ctx, req.Data)
	case "add_finding":
		return pt.addFinding(ctx, req.Data)
	case "log_command":
		return pt.logCommand(ctx, req.Data)
	case "get_session":
		return pt.getSession(ctx, req.Data)
	case "generate_report":
		return pt.generateReport(ctx, req.Data)
	default:
		return nil, fmt.Errorf("unknown pentest action: %s", req.Action)
	}
}

// createTarget creates a new penetration testing target
func (pt *PentestTool) createTarget(ctx context.Context, data json.RawMessage) ([]llm.Content, error) {
	var target PentestTarget
	if err := json.Unmarshal(data, &target); err != nil {
		return nil, fmt.Errorf("failed to unmarshal target data: %w", err)
	}

	// Set timestamps
	now := time.Now()
	target.CreatedAt = now
	target.UpdatedAt = now

	// Generate ID if not provided
	if target.ID == "" {
		target.ID = fmt.Sprintf("target_%d", now.Unix())
	}

	// Save target to file
	if err := pt.saveTarget(ctx, target); err != nil {
		return nil, fmt.Errorf("failed to save target: %w", err)
	}

	result := fmt.Sprintf("‚úÖ Created penetration testing target:\n"+
		"ID: %s\n"+
		"Name: %s\n"+
		"IP: %s\n"+
		"Scope: %s\n"+
		"Description: %s",
		target.ID, target.Name, target.IPAddress,
		strings.Join(target.Scope, ", "), target.Description)

	return llm.TextContent(result), nil
}

// startSession starts a new penetration testing session
func (pt *PentestTool) startSession(ctx context.Context, data json.RawMessage) ([]llm.Content, error) {
	var input struct {
		TargetID string `json:"target_id"`
	}
	if err := json.Unmarshal(data, &input); err != nil {
		return nil, fmt.Errorf("failed to unmarshal session input: %w", err)
	}

	// Load target
	target, err := pt.loadTarget(ctx, input.TargetID)
	if err != nil {
		return nil, fmt.Errorf("failed to load target: %w", err)
	}

	// Create session
	session := PentestSession{
		ID:        fmt.Sprintf("session_%d", time.Now().Unix()),
		Target:    *target,
		Phase:     "reconnaissance",
		Status:    "active",
		StartTime: time.Now(),
		Findings:  []Finding{},
		Notes:     []string{},
		Commands:  []CommandLog{},
	}

	// Save session
	if err := pt.saveSession(ctx, session); err != nil {
		return nil, fmt.Errorf("failed to save session: %w", err)
	}

	result := fmt.Sprintf("üéØ Started penetration testing session:\n"+
		"Session ID: %s\n"+
		"Target: %s (%s)\n"+
		"Phase: %s\n"+
		"Status: %s\n"+
		"Started: %s",
		session.ID, session.Target.Name, session.Target.IPAddress,
		session.Phase, session.Status, session.StartTime.Format(time.RFC3339))

	return llm.TextContent(result), nil
}

// updatePhase updates the current phase of a pentesting session
func (pt *PentestTool) updatePhase(ctx context.Context, data json.RawMessage) ([]llm.Content, error) {
	var input struct {
		SessionID string `json:"session_id"`
		Phase     string `json:"phase"`
		Notes     string `json:"notes,omitempty"`
	}
	if err := json.Unmarshal(data, &input); err != nil {
		return nil, fmt.Errorf("failed to unmarshal phase update: %w", err)
	}

	// Load session
	session, err := pt.loadSession(ctx, input.SessionID)
	if err != nil {
		return nil, fmt.Errorf("failed to load session: %w", err)
	}

	// Update phase
	oldPhase := session.Phase
	session.Phase = input.Phase
	if input.Notes != "" {
		session.Notes = append(session.Notes, fmt.Sprintf("[%s] Phase transition: %s -> %s: %s",
			time.Now().Format(time.RFC3339), oldPhase, input.Phase, input.Notes))
	}

	// Save session
	if err := pt.saveSession(ctx, *session); err != nil {
		return nil, fmt.Errorf("failed to save session: %w", err)
	}

	result := fmt.Sprintf("üìã Updated pentesting phase:\n"+
		"Session: %s\n"+
		"Previous Phase: %s\n"+
		"Current Phase: %s\n"+
		"Notes: %s",
		session.ID, oldPhase, session.Phase, input.Notes)

	return llm.TextContent(result), nil
}

// addFinding adds a security finding to the session
func (pt *PentestTool) addFinding(ctx context.Context, data json.RawMessage) ([]llm.Content, error) {
	var input struct {
		SessionID string  `json:"session_id"`
		Finding   Finding `json:"finding"`
	}
	if err := json.Unmarshal(data, &input); err != nil {
		return nil, fmt.Errorf("failed to unmarshal finding: %w", err)
	}

	// Load session
	session, err := pt.loadSession(ctx, input.SessionID)
	if err != nil {
		return nil, fmt.Errorf("failed to load session: %w", err)
	}

	// Set finding metadata
	if input.Finding.ID == "" {
		input.Finding.ID = fmt.Sprintf("finding_%d", time.Now().Unix())
	}
	input.Finding.CreatedAt = time.Now()

	// Add finding to session
	session.Findings = append(session.Findings, input.Finding)

	// Save session
	if err := pt.saveSession(ctx, *session); err != nil {
		return nil, fmt.Errorf("failed to save session: %w", err)
	}

	result := fmt.Sprintf("üö® Added security finding:\n"+
		"ID: %s\n"+
		"Title: %s\n"+
		"Severity: %s\n"+
		"Description: %s\n"+
		"CVSS: %.1f",
		input.Finding.ID, input.Finding.Title, input.Finding.Severity,
		input.Finding.Description, input.Finding.CVSS)

	return llm.TextContent(result), nil
}

// logCommand logs an executed command
func (pt *PentestTool) logCommand(ctx context.Context, data json.RawMessage) ([]llm.Content, error) {
	var input struct {
		SessionID string     `json:"session_id"`
		Command   CommandLog `json:"command"`
	}
	if err := json.Unmarshal(data, &input); err != nil {
		return nil, fmt.Errorf("failed to unmarshal command log: %w", err)
	}

	// Load session
	session, err := pt.loadSession(ctx, input.SessionID)
	if err != nil {
		return nil, fmt.Errorf("failed to load session: %w", err)
	}

	// Set timestamp if not provided
	if input.Command.Timestamp.IsZero() {
		input.Command.Timestamp = time.Now()
	}

	// Set phase if not provided
	if input.Command.Phase == "" {
		input.Command.Phase = session.Phase
	}

	// Add command to session
	session.Commands = append(session.Commands, input.Command)

	// Save session
	if err := pt.saveSession(ctx, *session); err != nil {
		return nil, fmt.Errorf("failed to save session: %w", err)
	}

	result := fmt.Sprintf("üìù Logged command execution:\n"+
		"Command: %s\n"+
		"Exit Code: %d\n"+
		"Phase: %s\n"+
		"Timestamp: %s",
		input.Command.Command, input.Command.ExitCode,
		input.Command.Phase, input.Command.Timestamp.Format(time.RFC3339))

	return llm.TextContent(result), nil
}

// getSession retrieves session information
func (pt *PentestTool) getSession(ctx context.Context, data json.RawMessage) ([]llm.Content, error) {
	var input struct {
		SessionID string `json:"session_id"`
	}
	if err := json.Unmarshal(data, &input); err != nil {
		return nil, fmt.Errorf("failed to unmarshal session query: %w", err)
	}

	// Load session
	session, err := pt.loadSession(ctx, input.SessionID)
	if err != nil {
		return nil, fmt.Errorf("failed to load session: %w", err)
	}

	// Format session info
	result := fmt.Sprintf("üìä Penetration Testing Session Status:\n\n"+
		"Session ID: %s\n"+
		"Target: %s (%s)\n"+
		"Current Phase: %s\n"+
		"Status: %s\n"+
		"Duration: %s\n"+
		"Findings: %d\n"+
		"Commands Executed: %d\n\n",
		session.ID, session.Target.Name, session.Target.IPAddress,
		session.Phase, session.Status,
		time.Since(session.StartTime).Round(time.Minute),
		len(session.Findings), len(session.Commands))

	// Add recent findings
	if len(session.Findings) > 0 {
		result += "Recent Findings:\n"
		for i, finding := range session.Findings {
			if i >= 5 { // Show only last 5 findings
				break
			}
			result += fmt.Sprintf("- %s (%s): %s\n",
				finding.Title, finding.Severity, finding.Description)
		}
	}

	return llm.TextContent(result), nil
}

// generateReport generates a penetration testing report
func (pt *PentestTool) generateReport(ctx context.Context, data json.RawMessage) ([]llm.Content, error) {
	var input struct {
		SessionID string `json:"session_id"`
		Format    string `json:"format,omitempty"`
	}
	if err := json.Unmarshal(data, &input); err != nil {
		return nil, fmt.Errorf("failed to unmarshal report request: %w", err)
	}

	if input.Format == "" {
		input.Format = "markdown"
	}

	// Load session
	session, err := pt.loadSession(ctx, input.SessionID)
	if err != nil {
		return nil, fmt.Errorf("failed to load session: %w", err)
	}

	// Generate report
	report := pt.formatReport(*session, input.Format)

	// Save report to file
	reportPath := filepath.Join(WorkingDir(ctx), fmt.Sprintf("pentest_report_%s.md", session.ID))
	if err := os.WriteFile(reportPath, []byte(report), 0644); err != nil {
		return nil, fmt.Errorf("failed to save report: %w", err)
	}

	result := fmt.Sprintf("üìÑ Generated penetration testing report:\n"+
		"Session: %s\n"+
		"Format: %s\n"+
		"File: %s\n"+
		"Findings: %d\n"+
		"Commands: %d",
		session.ID, input.Format, reportPath,
		len(session.Findings), len(session.Commands))

	return llm.TextContent(result), nil
}

// Helper functions for file operations
func (pt *PentestTool) saveTarget(ctx context.Context, target PentestTarget) error {
	data, err := json.MarshalIndent(target, "", "  ")
	if err != nil {
		return err
	}

	targetPath := filepath.Join(WorkingDir(ctx), fmt.Sprintf("target_%s.json", target.ID))
	return os.WriteFile(targetPath, data, 0644)
}

func (pt *PentestTool) loadTarget(ctx context.Context, targetID string) (*PentestTarget, error) {
	targetPath := filepath.Join(WorkingDir(ctx), fmt.Sprintf("target_%s.json", targetID))
	data, err := os.ReadFile(targetPath)
	if err != nil {
		return nil, err
	}

	var target PentestTarget
	if err := json.Unmarshal(data, &target); err != nil {
		return nil, err
	}

	return &target, nil
}

func (pt *PentestTool) saveSession(ctx context.Context, session PentestSession) error {
	data, err := json.MarshalIndent(session, "", "  ")
	if err != nil {
		return err
	}

	sessionPath := filepath.Join(WorkingDir(ctx), fmt.Sprintf("session_%s.json", session.ID))
	return os.WriteFile(sessionPath, data, 0644)
}

func (pt *PentestTool) loadSession(ctx context.Context, sessionID string) (*PentestSession, error) {
	sessionPath := filepath.Join(WorkingDir(ctx), fmt.Sprintf("session_%s.json", sessionID))
	data, err := os.ReadFile(sessionPath)
	if err != nil {
		return nil, err
	}

	var session PentestSession
	if err := json.Unmarshal(data, &session); err != nil {
		return nil, err
	}

	return &session, nil
}

// formatReport formats a penetration testing report
func (pt *PentestTool) formatReport(session PentestSession, format string) string {
	var report strings.Builder

	// Header
	report.WriteString("# Penetration Testing Report\n\n")
	report.WriteString(fmt.Sprintf("**Session ID:** %s\n", session.ID))
	report.WriteString(fmt.Sprintf("**Target:** %s (%s)\n", session.Target.Name, session.Target.IPAddress))
	report.WriteString(fmt.Sprintf("**Test Period:** %s", session.StartTime.Format("2006-01-02 15:04:05")))
	if session.EndTime != nil {
		report.WriteString(fmt.Sprintf(" - %s", session.EndTime.Format("2006-01-02 15:04:05")))
	}
	report.WriteString("\n\n")

	// Executive Summary
	report.WriteString("## Executive Summary\n\n")
	report.WriteString(fmt.Sprintf("This report documents the penetration testing activities conducted against %s (%s). ",
		session.Target.Name, session.Target.IPAddress))
	report.WriteString(fmt.Sprintf("A total of %d security findings were identified during the assessment.\n\n",
		len(session.Findings)))

	// Scope
	report.WriteString("## Scope\n\n")
	report.WriteString("**In Scope:**\n")
	for _, scope := range session.Target.Scope {
		report.WriteString(fmt.Sprintf("- %s\n", scope))
	}
	if len(session.Target.OutOfScope) > 0 {
		report.WriteString("\n**Out of Scope:**\n")
		for _, outScope := range session.Target.OutOfScope {
			report.WriteString(fmt.Sprintf("- %s\n", outScope))
		}
	}
	report.WriteString("\n")

	// Methodology
	report.WriteString("## Methodology\n\n")
	report.WriteString("The penetration test followed a structured approach:\n")
	report.WriteString("1. **Reconnaissance** - Information gathering and target enumeration\n")
	report.WriteString("2. **Scanning** - Port scanning and service identification\n")
	report.WriteString("3. **Vulnerability Assessment** - Identification of security weaknesses\n")
	report.WriteString("4. **Exploitation** - Attempting to exploit identified vulnerabilities\n")
	report.WriteString("5. **Reporting** - Documentation of findings and recommendations\n\n")

	// Findings
	if len(session.Findings) > 0 {
		report.WriteString("## Findings\n\n")

		// Group findings by severity
		severityOrder := []string{"Critical", "High", "Medium", "Low", "Informational"}
		for _, severity := range severityOrder {
			var severityFindings []Finding
			for _, finding := range session.Findings {
				if strings.EqualFold(finding.Severity, severity) {
					severityFindings = append(severityFindings, finding)
				}
			}

			if len(severityFindings) > 0 {
				report.WriteString(fmt.Sprintf("### %s Severity\n\n", severity))
				for _, finding := range severityFindings {
					report.WriteString(fmt.Sprintf("#### %s\n\n", finding.Title))
					report.WriteString(fmt.Sprintf("**Severity:** %s\n", finding.Severity))
					if finding.CVSS > 0 {
						report.WriteString(fmt.Sprintf("**CVSS Score:** %.1f\n", finding.CVSS))
					}
					if finding.CVE != "" {
						report.WriteString(fmt.Sprintf("**CVE:** %s\n", finding.CVE))
					}
					report.WriteString(fmt.Sprintf("**Description:** %s\n\n", finding.Description))

					if len(finding.Evidence) > 0 {
						report.WriteString("**Evidence:**\n")
						for _, evidence := range finding.Evidence {
							report.WriteString(fmt.Sprintf("- %s\n", evidence))
						}
						report.WriteString("\n")
					}

					if finding.Remediation != "" {
						report.WriteString(fmt.Sprintf("**Remediation:** %s\n\n", finding.Remediation))
					}

					if len(finding.References) > 0 {
						report.WriteString("**References:**\n")
						for _, ref := range finding.References {
							report.WriteString(fmt.Sprintf("- %s\n", ref))
						}
						report.WriteString("\n")
					}

					report.WriteString("---\n\n")
				}
			}
		}
	}

	// Command Log
	if len(session.Commands) > 0 {
		report.WriteString("## Command Execution Log\n\n")
		report.WriteString("| Timestamp | Phase | Command | Exit Code |\n")
		report.WriteString("|-----------|-------|---------|----------|\n")
		for _, cmd := range session.Commands {
			report.WriteString(fmt.Sprintf("| %s | %s | `%s` | %d |\n",
				cmd.Timestamp.Format("15:04:05"), cmd.Phase, cmd.Command, cmd.ExitCode))
		}
		report.WriteString("\n")
	}

	// Conclusion
	report.WriteString("## Conclusion\n\n")
	report.WriteString("This penetration test has identified several areas for security improvement. ")
	report.WriteString("It is recommended to address the findings in order of severity, starting with Critical and High severity issues.\n\n")

	return report.String()
}

const (
	pentestInputSchema = `{
		"type": "object",
		"properties": {
			"action": {
				"type": "string",
				"enum": ["create_target", "start_session", "update_phase", "add_finding", "log_command", "get_session", "generate_report"],
				"description": "The pentesting action to perform: create_target (define new target), start_session (begin testing session), update_phase (change testing phase), add_finding (record security finding), log_command (record executed command), get_session (retrieve session info), generate_report (create final report)"
			},
			"data": {
				"type": "object",
				"description": "Action-specific data payload containing parameters for the selected action",
				"additionalProperties": true
			}
		},
		"required": ["action"]
	}`
)

// PentestToolInstance is the tool instance for pentesting workflow management
var PentestToolInstance = &llm.Tool{
	Name:        "pentest",
	Description: "Manage penetration testing workflows including targets, sessions, findings, and reports. Supports systematic pentesting methodology with session tracking, finding documentation, and professional report generation.",
	InputSchema: llm.MustSchema(pentestInputSchema),
	Run: func(ctx context.Context, input json.RawMessage) ([]llm.Content, error) {
		tool := &PentestTool{}
		return tool.Run(ctx, input)
	},
}
